{"version":3,"sources":["../src/textlint-rule-ja-unnatural-alphabet.js"],"names":["escapeStringRegexp","require","matchCaptureGroupAll","regx","default","japaneseRegExp","alphabetPattern","unnaturalPattern","matchUnnaturalAlphabet","text","isIgnoredRange","exceptGroups","actual","some","index","endIndex","length","createIgnoreRanges","input","allowAlphabets","patterns","map","allowWord","regExpString","slice","RegExp","escapeString","reduce","total","pattern","concat","builtInCommonAllow","defaultOptions","report","context","options","Syntax","RuleError","getSource","allow","allowCommonCase","undefined","Str","node","ignoreMatch","forEach","module","exports"],"mappings":"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","file":"textlint-rule-ja-unnatural-alphabet.js","sourcesContent":["// MIT © 2017 azu\n\"use strict\";\nconst escapeStringRegexp = require('escape-string-regexp');\nconst matchCaptureGroupAll = require(\"match-index\").matchCaptureGroupAll;\nconst regx = require(\"regx\").default;\n// IME的に入力されそうな文字列\n// 日本語 + 記号\nconst japaneseRegExp = /(?:[々〇〻\\u3400-\\u4DBF\\u4E00-\\u9FFF\\uF900-\\uFAFF]|[\\uD840-\\uD87F]|[\\uFF00-\\uFFEF]|[\\uDC00-\\uDFFF]|[ぁ-んァ-ヶー。、・−])/;\n// 半角/全角のアルファベットの正規表現\nconst alphabetPattern = /([a-zA-Zａ-ｚＡ-Ｚ])/;\n/**\n * 不自然なアルファベットの正規表現\n * @type {RegExp}\n */\nconst unnaturalPattern = regx(\"g\")`${japaneseRegExp}${alphabetPattern}${japaneseRegExp}`;\n/***\n * 不自然なアルファベットのグループを返す\n * @param {string} text\n * @returns {MatchCaptureGroup[]}\n */\nconst matchUnnaturalAlphabet = (text) => {\n    return matchCaptureGroupAll(text, unnaturalPattern);\n};\n\n/**\n * if actual is in the `exceptGroups`, return true\n * @param {MatchCaptureGroup[]} exceptGroups\n * @param {MatchCaptureGroup} actual\n * @returns {boolean}\n */\nconst isIgnoredRange = (exceptGroups, actual) => {\n    return exceptGroups.some(({ text, index }) => {\n        const endIndex = index + text.length;\n        return index <= actual.index && actual.index <= endIndex;\n    });\n};\n/***\n *\n * @param {string} input\n * @param {string[]} allowAlphabets\n * @returns {MatchCaptureGroup[]}\n */\nconst createIgnoreRanges = (input, allowAlphabets) => {\n    // str -> RegExp\n    const patterns = allowAlphabets.map(allowWord => {\n        if (!allowWord) {\n            return /^$/;\n        }\n        if (allowWord[0] === \"/\" && allowWord[allowWord.length - 1] === \"/\") {\n            const regExpString = allowWord.slice(1, allowWord.length - 1);\n            return new RegExp(`(${regExpString})`, \"g\");\n        }\n        const escapeString = escapeStringRegexp(allowWord);\n        return new RegExp(`(${escapeString})`, \"g\");\n    });\n    return patterns.reduce((total, pattern) => {\n        return total.concat(matchCaptureGroupAll(input, pattern));\n    }, []);\n};\n\n/**\n * ビルトインの無視するリスト\n * @type {[*]}\n */\nconst builtInCommonAllow = [\n    \"/[a-zA-Zａ-ｚＡ-Ｚ]言語/\",\n    \"/[x-zX-Z]座標/\",\n    \"/[x-zX-Z]軸/\",\n    \"Eメール\"\n];\nconst defaultOptions = {\n    // 無視するアルファベット\n    // 例) [\"X\"]\n    // デフォルトでは母音とnを除外\n    \"allow\": [\n        \"a\", \"i\", \"u\", \"e\", \"o\", \"n\"\n    ],\n    // ビルトインの典型例を除外するかどうか\n    // 例) C言語\n    \"allowCommonCase\": true\n};\nconst report = (context, options = {}) => {\n    const { Syntax, RuleError, report, getSource } = context;\n    const allowAlphabets = options.allow || defaultOptions.allow;\n    const allowCommonCase = options.allowCommonCase !== undefined\n        ? options.allowCommonCase\n        : defaultOptions.allowCommonCase;\n    const allow = allowCommonCase ? allowAlphabets.concat(builtInCommonAllow) : allowAlphabets;\n    return {\n        [Syntax.Str](node){\n            const text = getSource(node);\n            const ignoreMatch = createIgnoreRanges(text, allow);\n            matchUnnaturalAlphabet(text).forEach((actual) => {\n                const { text, index } = actual;\n                // 無視する単語を含んでいるなら無視\n                if (isIgnoredRange(ignoreMatch, actual)) {\n                    return;\n                }\n                report(node, new RuleError(`不自然なアルファベットがあります: ${text}`, {\n                    index\n                }));\n            });\n        }\n    }\n};\n\nmodule.exports = report;\n"]}