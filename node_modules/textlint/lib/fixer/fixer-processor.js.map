{"version":3,"sources":["../../src/fixer/fixer-processor.js"],"names":["debug","require","FixerProcessor","processor","messageProcessManager","config","ruleCreatorSet","filterRuleCreatorSet","sourceCode","ext","preProcess","postProcess","resultFilePath","filePath","applyingMessages","remainingMessages","originalMessages","fixerProcessList","mapFixer","sourceText","newSourceCode","text","ast","task","fixerRuleCreatorSet","process","then","result","messages","applied","applyFixes","Array","prototype","push","apply","fixed","output","promiseTask","reduce","promise","fixerProcess","Promise","resolve","length"],"mappings":"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","file":"fixer-processor.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nconst debug = require(\"debug\")(\"textlint:fixer-processor\");\nimport assert from \"assert\";\nimport FixerTask from \"../task/fixer-task\";\nimport SourceCode from \"../core/source-code\";\nimport SourceCodeFixer from \"../fixer/source-code-fixer\";\nimport TaskRunner from \"../task/task-runner\";\nexport default class FixerProcessor {\n    /**\n     * @param {Processor} processor\n     * @param {MessageProcessManager} messageProcessManager\n     */\n    constructor(processor, messageProcessManager) {\n        this.processor = processor;\n        this.messageProcessManager = messageProcessManager;\n    }\n\n    /**\n     * Run fixer process\n     * @param {Config} config\n     * @param {RuleCreatorSet} ruleCreatorSet\n     * @param {RuleCreatorSet} filterRuleCreatorSet\n     * @param {SourceCode} sourceCode\n     * @returns {Promise.<TextLintFixResult>}\n     */\n    process({config, ruleCreatorSet, filterRuleCreatorSet, sourceCode}) {\n        assert(config && ruleCreatorSet && sourceCode);\n        const {preProcess, postProcess} = this.processor.processor(sourceCode.ext);\n        // messages\n        let resultFilePath = sourceCode.filePath;\n        // applied fixing messages\n        // Revert = Sequentially apply applied message to applied output\n        // SourceCodeFixer.sequentiallyApplyFixes(fixedOutput, result.applyingMessages);\n        const applyingMessages = [];\n        // not applied fixing messages\n        const remainingMessages = [];\n        // original means original for applyingMessages and remainingMessages\n        // pre-applyingMessages + remainingMessages\n        const originalMessages = [];\n        const fixerProcessList = ruleCreatorSet.mapFixer(fixerRuleCreatorSet => {\n            return (sourceText) => {\n                // create new SourceCode object\n                const newSourceCode = new SourceCode({\n                    text: sourceText,\n                    ast: preProcess(sourceText),\n                    filePath: resultFilePath,\n                    ext: sourceCode.ext\n                });\n                // create new Task\n                const task = new FixerTask({\n                    config,\n                    ruleCreatorSet: fixerRuleCreatorSet,\n                    filterRuleCreatorSet,\n                    sourceCode: newSourceCode\n                });\n\n                return TaskRunner.process(task).then(messages => {\n                    const result = postProcess(messages, sourceCode.filePath);\n                    result.messages = this.messageProcessManager.process(result.messages);\n                    if (result.filePath == null) {\n                        result.filePath = `<Unkown${sourceCode.ext}>`;\n                    }\n                    resultFilePath = result.filePath;\n                    const applied = SourceCodeFixer.applyFixes(newSourceCode, result.messages);\n                    // add messages\n                    Array.prototype.push.apply(applyingMessages, applied.applyingMessages);\n                    Array.prototype.push.apply(remainingMessages, applied.remainingMessages);\n                    Array.prototype.push.apply(originalMessages, applied.messages);\n                    // if not fixed, still use current sourceText\n                    if (!applied.fixed) {\n                        return sourceText;\n                    }\n                    // if fixed, use fixed text at next\n                    return applied.output;\n                });\n            };\n        });\n\n        const promiseTask = fixerProcessList.reduce((promise, fixerProcess) => {\n            return promise.then((sourceText) => {\n                return fixerProcess(sourceText);\n            });\n        }, Promise.resolve(sourceCode.text));\n\n        return promiseTask.then(output => {\n            debug(`Finish Processing: ${resultFilePath}`);\n            debug(`applyingMessages: ${applyingMessages.length}`);\n            debug(`remainingMessages: ${remainingMessages.length}`);\n            return {\n                filePath: resultFilePath,\n                output,\n                messages: originalMessages,\n                applyingMessages,\n                remainingMessages\n            };\n        });\n    }\n}\n"]}