{"version":3,"sources":["../src/textlint-rule-ja-no-weak-phrase.js"],"names":["tokenize","require","createTokenMatcher","module","exports","context","Syntax","RuleError","report","getSource","matcherList","map","matcher","dict","message","Str","node","text","then","currentTokens","forEach","token","match","tokens","firstToken","index","word_position"],"mappings":"AAAA;AACA;;AAEA;;;;;;;;AADA,IAAMA,WAAWC,QAAQ,WAAR,EAAqBD,QAAtC;;AAEA,IAAME,qBAAqBD,QAAQ,gBAAR,CAA3B;AACAE,OAAOC,OAAP,GAAiB,UAAUC,OAAV,EAAmB;AAAA,QACzBC,MADyB,GACeD,OADf,CACzBC,MADyB;AAAA,QACjBC,SADiB,GACeF,OADf,CACjBE,SADiB;AAAA,QACNC,MADM,GACeH,OADf,CACNG,MADM;AAAA,QACEC,SADF,GACeJ,OADf,CACEI,SADF;;AAEhC,QAAMC,cAAc,eAAeC,GAAf,CAAmB,gBAAQ;AAC3C,eAAO;AACHC,qBAASV,mBAAmBW,KAAK,QAAL,CAAnB,CADN;AAEHC,qBAASD,KAAK,SAAL;AAFN,SAAP;AAIH,KALmB,CAApB;AAMA,+BACKP,OAAOS,GADZ,YACiBC,IADjB,EACsB;AACd,YAAMC,OAAOR,UAAUO,IAAV,CAAb;AACA,eAAOhB,SAASiB,IAAT,EAAeC,IAAf,CAAoB,yBAAiB;AACxCC,0BAAcC,OAAd,CAAsB,iBAAS;AAC3BV,4BAAYU,OAAZ,CAAoB,gBAAwB;AAAA,wBAAtBR,OAAsB,QAAtBA,OAAsB;AAAA,wBAAbE,OAAa,QAAbA,OAAa;;AAAA,mCAChBF,QAAQS,KAAR,CADgB;AAAA,wBACjCC,KADiC,YACjCA,KADiC;AAAA,wBAC1BC,MAD0B,YAC1BA,MAD0B;;AAExC,wBAAI,CAACD,KAAL,EAAY;AACR;AACH;AACD,wBAAME,aAAaD,OAAO,CAAP,CAAnB;AACAf,2BAAOQ,IAAP,EAAa,IAAIT,SAAJ,CAAcO,OAAd,EAAuB;AAChCW,+BAAOD,WAAWE,aAAX,GAA2B;AADF,qBAAvB,CAAb;AAGH,iBATD;AAUH,aAXD;AAYH,SAbM,CAAP;AAcH,KAjBL;AAmBH,CA3BD","file":"textlint-rule-ja-no-weak-phrase.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nconst tokenize = require(\"kuromojin\").tokenize;\nimport dictionaryList from \"./dict\";\nconst createTokenMatcher = require(\"morpheme-match\");\nmodule.exports = function (context) {\n    const {Syntax, RuleError, report, getSource} = context;\n    const matcherList = dictionaryList.map(dict => {\n        return {\n            matcher: createTokenMatcher(dict[\"tokens\"]),\n            message: dict[\"message\"]\n        };\n    });\n    return {\n        [Syntax.Str](node){\n            const text = getSource(node);\n            return tokenize(text).then(currentTokens => {\n                currentTokens.forEach(token => {\n                    matcherList.forEach(({matcher, message}) => {\n                        const {match, tokens} = matcher(token);\n                        if (!match) {\n                            return;\n                        }\n                        const firstToken = tokens[0];\n                        report(node, new RuleError(message, {\n                            index: firstToken.word_position - 1\n                        }));\n                    });\n                });\n            });\n        }\n    }\n};"]}