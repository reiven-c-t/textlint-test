{"version":3,"sources":["../src/sentence-length.js"],"names":["context","options","maxLength","max","defaultOptions","helper","Syntax","RuleError","report","Paragraph","node","isChildNode","BlockQuote","isChildrenSingleLinkNode","children","length","type","Link","text","sentences","newLineCharacters","forEach","sentenceText","sentence","value","currentLine","loc","start","line","addedLine","isStartWithNewLine","paddingLine","Math","paddingIndex","range","index","charAt"],"mappings":"AAAA;AACA;;;;;;kBAUe,UAASA,OAAT,EAAgC;AAAA,QAAdC,OAAc,uEAAJ,EAAI;;AAC3C,QAAMC,YAAYD,QAAQE,GAAR,IAAeC,eAAeD,GAAhD;AACA,QAAME,SAAS,mCAAeL,OAAf,CAAf;AAF2C,QAGpCM,MAHoC,GAGPN,OAHO,CAGpCM,MAHoC;AAAA,QAG5BC,SAH4B,GAGPP,OAHO,CAG5BO,SAH4B;AAAA,QAGjBC,MAHiB,GAGPR,OAHO,CAGjBQ,MAHiB;AAI3C;;AACA,+BACKF,OAAOG,SADZ,YACuBC,IADvB,EAC4B;AACpB,YAAIL,OAAOM,WAAP,CAAmBD,IAAnB,EAAyB,CAACJ,OAAOM,UAAR,CAAzB,CAAJ,EAAmD;AAC/C;AACH;AACD;AACA,YAAMC,2BAA2BH,KAAKI,QAAL,CAAcC,MAAd,KAAyB,CAAzB,IAA8BL,KAAKI,QAAL,CAAc,CAAd,EAAiBE,IAAjB,KAA0BV,OAAOW,IAAhG;AACA,YAAIJ,wBAAJ,EAA8B;AAC1B;AACH;AACD,YAAMK,OAAO,iCAASR,IAAT,CAAb;AACA;AACA,YAAMS,YAAY,6BAAMD,IAAN,EAAY;AAC1BE,+BAAmB;AADO,SAAZ,CAAlB;AAGAD,kBAAUE,OAAV,CAAkB,oBAAY;AAC1B;AACA,gBAAIC,eAAeC,SAASC,KAA5B;AACA;AACA,gBAAIF,aAAaP,MAAb,GAAsBb,SAA1B,EAAqC;AACjC,oBAAMuB,cAAcf,KAAKgB,GAAL,CAASC,KAAT,CAAeC,IAAnC;AACA,oBAAMC,YAAYC,mBAAmBR,YAAnB,IACZC,SAASG,GAAT,CAAaC,KAAb,CAAmBC,IADP,CACY;AADZ,kBAEZL,SAASG,GAAT,CAAaC,KAAb,CAAmBC,IAAnB,GAA0B,CAFhC,CAFiC,CAIE;AACnC,oBAAIG,cAAcC,KAAK7B,GAAL,CAAS0B,SAAT,EAAoB,CAApB,CAAlB;AACA,oBAAII,eAAeV,SAASW,KAAT,CAAe,CAAf,CAAnB;AACA1B,uBAAOE,IAAP,EAAa,IAAIH,SAAJ,YAAsBkB,cAAcM,WAApC,6CAAsF7B,SAAtF,QAAoG;AAC7GiC,2BAAOF;AADsG,iBAApG,CAAb;AAGH;AACJ,SAfD;AAgBH,KA/BL;AAiCH,C;;AA/CD;;AACA;;;;AACA;;;;;;AACA,IAAMH,qBAAqB,SAArBA,kBAAqB,CAACZ,IAAD,EAAU;AACjC,WAAOA,QAAQA,KAAKkB,MAAL,CAAY,CAAZ,MAAmB,IAAlC;AACH,CAFD;AAGA,IAAMhC,iBAAiB;AACnBD,SAAK;AADc,CAAvB","file":"sentence-length.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nimport {split} from \"sentence-splitter\";\nimport toString from 'mdast-util-to-string';\nimport {RuleHelper} from \"textlint-rule-helper\";\nconst isStartWithNewLine = (text) => {\n    return text && text.charAt(0) === \"\\n\";\n};\nconst defaultOptions = {\n    max: 100\n};\nexport default function(context, options = {}) {\n    const maxLength = options.max || defaultOptions.max;\n    const helper = new RuleHelper(context);\n    const {Syntax, RuleError, report} = context;\n    // toPlainText\n    return {\n        [Syntax.Paragraph](node){\n            if (helper.isChildNode(node, [Syntax.BlockQuote])) {\n                return;\n            }\n            // If a single Link node in the paragraph node, should be ignore the link length\n            const isChildrenSingleLinkNode = node.children.length === 1 && node.children[0].type === Syntax.Link;\n            if (isChildrenSingleLinkNode) {\n                return;\n            }\n            const text = toString(node);\n            // empty break line == split sentence\n            const sentences = split(text, {\n                newLineCharacters: \"\\n\\n\"\n            });\n            sentences.forEach(sentence => {\n                // TODO: should trim()?\n                let sentenceText = sentence.value;\n                // larger than > 100\n                if (sentenceText.length > maxLength) {\n                    const currentLine = node.loc.start.line;\n                    const addedLine = isStartWithNewLine(sentenceText)\n                        ? sentence.loc.start.line // \\n string\n                        : sentence.loc.start.line - 1; // string\n                    let paddingLine = Math.max(addedLine, 0);\n                    let paddingIndex = sentence.range[0];\n                    report(node, new RuleError(`Line ${currentLine + paddingLine} exceeds the maximum line length of ${maxLength}.`, {\n                        index: paddingIndex\n                    }));\n                }\n            });\n        }\n    }\n}"]}