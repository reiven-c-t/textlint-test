{"version":3,"sources":["../../src/fixer/source-code-fixer.js"],"names":["debug","require","BOM","compareMessagesByLocation","a","b","lineDiff","line","column","clone","object","JSON","parse","stringify","SourceCodeFixer","sourceCode","messages","text","remainingMessages","applyingMessages","cloneMessages","slice","fixes","lastFixPos","length","prefix","hasBOM","forEach","problem","hasOwnProperty","push","sort","fix","range","chars","split","start","end","insertionText","replacedChars","splice","copyOfMessage","join","fixed","reverse","output","newSource","ast","ext","filePath","result","applyFixes","message"],"mappings":"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","file":"source-code-fixer.js","sourcesContent":["const debug = require(\"debug\")(\"textlint:source-code-fixer\");\nimport SourceCode from \"../core/source-code\";\nconst BOM = \"\\uFEFF\";\n\n/**\n * Compares items in a messages array by line and column.\n * @param {TextLintMessage} a The first message.\n * @param {TextLintMessage} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareMessagesByLocation(a, b) {\n    const lineDiff = a.line - b.line;\n\n    if (lineDiff === 0) {\n        return a.column - b.column;\n    } else {\n        return lineDiff;\n    }\n}\n\nfunction clone(object) {\n    return JSON.parse(JSON.stringify(object));\n}\n/**\n * Utility for apply fixes to source code.\n * @constructor\n */\n\nexport default class SourceCodeFixer {\n    /**\n     * Applies the fixes specified by the messages to the given text. Tries to be\n     * smart about the fixes and won't apply fixes over the same area in the text.\n     * @param {SourceCode} sourceCode The source code to apply the changes to.\n     * @param {TextLintMessage[]} messages The array of messages reported by ESLint.\n     * @returns {Object} An object containing the fixed text and any unfixed messages.\n     */\n    static applyFixes(sourceCode, messages) {\n        debug(\"Applying fixes\");\n        const text = sourceCode.text;\n        // As as result, show diff\n        const remainingMessages = [];\n        const applyingMessages = [];\n        const cloneMessages = messages.slice();\n        const fixes = [];\n        let lastFixPos = text.length + 1;\n        let prefix = (sourceCode.hasBOM ? BOM : \"\");\n        cloneMessages.forEach(problem => {\n            if (problem && problem.hasOwnProperty(\"fix\")) {\n                fixes.push(problem);\n            } else {\n                remainingMessages.push(problem);\n            }\n        });\n\n        if (fixes.length) {\n            debug(\"Found fixes to apply\");\n\n            // sort in reverse order of occurrence\n            fixes.sort((a, b) => {\n                if (a.fix.range[1] <= b.fix.range[0]) {\n                    return 1;\n                } else {\n                    return -1;\n                }\n            });\n\n            // split into array of characters for easier manipulation\n            const chars = text.split(\"\");\n\n            fixes.forEach(problem => {\n                // pickup fix range\n                const fix = problem.fix;\n                let start = fix.range[0];\n                const end = fix.range[1];\n                let insertionText = fix.text;\n\n                if (end < lastFixPos) {\n                    if (start < 0) {\n                        // Remove BOM.\n                        prefix = \"\";\n                        start = 0;\n                    }\n                    if (start === 0 && insertionText[0] === BOM) {\n                        // Set BOM.\n                        prefix = BOM;\n                        insertionText = insertionText.slice(1);\n                    }\n\n                    const replacedChars = chars.splice(start, end - start, insertionText);\n                    lastFixPos = start;\n                    const copyOfMessage = clone(problem);\n                    copyOfMessage.fix = {\n                        range: [start, start + insertionText.length],\n                        text: replacedChars.join(\"\")\n                    };\n                    applyingMessages.push(copyOfMessage);\n                } else {\n                    remainingMessages.push(problem);\n                }\n            });\n\n            return {\n                fixed: true,\n                messages: cloneMessages,// have order\n                applyingMessages: applyingMessages.reverse(),// have order\n                remainingMessages: remainingMessages.sort(compareMessagesByLocation),// have not order\n                output: prefix + chars.join(\"\")\n            };\n        } else {\n            debug(\"No fixes to apply\");\n            return {\n                fixed: false,\n                messages: cloneMessages,\n                applyingMessages,\n                remainingMessages,\n                output: prefix + text\n            };\n        }\n    }\n\n    /**\n     * Sequentially Applies the fixes specified by the messages to the given text.\n     * @param {SourceCode} sourceCode The source code to apply the changes to.\n     * @param {TextLintMessage[]} applyingMessages The array of TextLintMessage reported by SourceCodeFixer#applyFixes\n     * @returns {string} An object containing the fixed text and any unfixed messages.\n     */\n    static sequentiallyApplyFixes(sourceCode, applyingMessages) {\n        debug(\"Restore applied fixes\");\n        let text = sourceCode.text;\n        applyingMessages.forEach(message => {\n            const newSource = new SourceCode({\n                text,\n                ast: sourceCode.ast, // it's dummy\n                ext: sourceCode.ext,\n                filePath: sourceCode.filePath\n            });\n            const result = SourceCodeFixer.applyFixes(newSource, [message]);\n            text = result.output;\n        });\n        return text;\n    }\n}\n"]}