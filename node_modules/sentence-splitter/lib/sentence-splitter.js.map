{"version":3,"sources":["../src/sentence-splitter.js"],"names":["split","createWhiteSpaceNode","createSentenceNode","assert","require","defaultOptions","charRegExp","separatorChars","newLineCharacters","Syntax","text","options","testCharIsSeparator","char","test","indexOf","src","createNode","type","start","end","range","location","rangeToLocation","slicedText","slice","node","WhiteSpace","Sentence","results","startPoint","currentIndex","isSplitPoint","newLineCharactersLength","length","whiteTarget","push","i","startIndex","loc","raw","value"],"mappings":"AAAA;AACA;;;;;;QAuBgBA,K,GAAAA,K;QA4EAC,oB,GAAAA,oB;QAeAC,kB,GAAAA,kB;;AAhHhB;;;;;;AADA,IAAMC,SAASC,QAAQ,QAAR,CAAf;;AAEA,IAAMC,iBAAiB;AACnB;AACAC,gBAAY,aAFO;AAGnB;AACAC,oBAAgB,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqB,GAArB,EAA0B,GAA1B,CAJG;AAKnBC,uBAAmB;AALA,CAAvB;AAOO,IAAMC,0BAAS;AAClB,kBAAc,YADI;AAElB,gBAAY;AAFM,CAAf;AAIP;;;;;;;;;AASO,SAAST,KAAT,CAAeU,IAAf,EAAmC;AAAA,QAAdC,OAAc,uEAAJ,EAAI;;AACtC,QAAML,aAAaK,QAAQL,UAA3B;AACA,QAAMC,iBAAiBI,QAAQJ,cAAR,IAA0BF,eAAeE,cAAhE;AACAJ,WAAO,EAAEQ,QAAQL,UAAR,IAAsBK,QAAQJ,cAAhC,CAAP,EAAwD,8DAClD,6BADN;AAEA;;;;;AAKA,QAAMK,sBAAsB,SAAtBA,mBAAsB,CAACC,IAAD,EAAU;AAClC,YAAIP,UAAJ,EAAgB;AACZ,mBAAOA,WAAWQ,IAAX,CAAgBD,IAAhB,CAAP;AACH;AACD,eAAON,eAAeQ,OAAf,CAAuBF,IAAvB,MAAiC,CAAC,CAAzC;AACH,KALD;AAMA,QAAML,oBAAoBG,QAAQH,iBAAR,IAA6BH,eAAeG,iBAAtE;AACA,QAAMQ,MAAM,+BAAoBN,IAApB,CAAZ;AACA,QAAIO,aAAa,SAAbA,UAAa,CAACC,IAAD,EAAOC,KAAP,EAAcC,GAAd,EAAsB;AACnC,YAAIC,QAAQ,CAACF,KAAD,EAAQC,GAAR,CAAZ;AACA,YAAIE,WAAWN,IAAIO,eAAJ,CAAoBF,KAApB,CAAf;AACA,YAAIG,aAAad,KAAKe,KAAL,CAAWN,KAAX,EAAkBC,GAAlB,CAAjB;AACA,YAAIM,aAAJ;AACA,YAAIR,SAAST,OAAOkB,UAApB,EAAgC;AAC5BD,mBAAOzB,qBAAqBuB,UAArB,EAAiCF,QAAjC,EAA2CD,KAA3C,CAAP;AACH,SAFD,MAEO,IAAIH,SAAST,OAAOmB,QAApB,EAA8B;AACjCF,mBAAOxB,mBAAmBsB,UAAnB,EAA+BF,QAA/B,EAAyCD,KAAzC,CAAP;AACH;AACD,eAAOK,IAAP;AACH,KAXD;AAYA,QAAIG,UAAU,EAAd;AACA,QAAIC,aAAa,CAAjB;AACA,QAAIC,eAAe,CAAnB;AACA,QAAIC,eAAe,KAAnB;AACA,QAAMC,0BAA0BzB,kBAAkB0B,MAAlD;AACA,WAAOH,eAAerB,KAAKwB,MAA3B,EAAmCH,cAAnC,EAAmD;AAC/C,YAAIlB,OAAOH,KAAKqB,YAAL,CAAX;AACA,YAAII,cAAczB,KAAKe,KAAL,CAAWM,YAAX,EAAyBA,eAAeE,uBAAxC,CAAlB;AACA,YAAIE,gBAAgB3B,iBAApB,EAAuC;AACnC;AACA,gBAAIsB,eAAeC,YAAnB,EAAiC;AAC7BF,wBAAQO,IAAR,CAAanB,WAAWR,OAAOmB,QAAlB,EAA4BE,UAA5B,EAAwCC,YAAxC,CAAb;AACH;AACD,iBAAK,IAAIM,IAAI,CAAb,EAAgBA,IAAIJ,uBAApB,EAA6CI,GAA7C,EAAkD;AAC9C;AACA,oBAAIC,aAAaP,eAAeM,CAAhC;AACAR,wBAAQO,IAAR,CAAanB,WAAWR,OAAOkB,UAAlB,EAA8BW,UAA9B,EAA0CA,aAAa,CAAvD,CAAb;AACH;AACD;AACAR,yBAAaC,eAAeE,uBAA5B;AACAD,2BAAe,KAAf;AACH,SAbD,MAaO,IAAIpB,oBAAoBC,IAApB,CAAJ,EAA+B;AAClCmB,2BAAe,IAAf;AACH,SAFM,MAEA;AACH;AACA;AACA,gBAAIA,YAAJ,EAAkB;AACdH,wBAAQO,IAAR,CAAanB,WAAWR,OAAOmB,QAAlB,EAA4BE,UAA5B,EAAwCC,YAAxC,CAAb;AACA;AACAD,6BAAaC,YAAb;AACAC,+BAAe,KAAf;AACH;AACJ;AACJ;;AAED,QAAIF,eAAeC,YAAnB,EAAiC;AAC7BF,gBAAQO,IAAR,CAAanB,WAAWR,OAAOmB,QAAlB,EAA4BE,UAA5B,EAAwCC,YAAxC,CAAb;AACH;AACD,WAAOF,OAAP;AACH;AACD;;;;;;AAMO,SAAS5B,oBAAT,CAA8BS,IAA9B,EAAoC6B,GAApC,EAAyClB,KAAzC,EAAgD;AACnD,WAAO;AACHH,cAAM,YADH;AAEHsB,aAAK9B,IAFF;AAGH+B,eAAO/B,IAHJ;AAIH6B,aAAKA,GAJF;AAKHlB,eAAOA;AALJ,KAAP;AAOH;AACD;;;;;;AAMO,SAASnB,kBAAT,CAA4BQ,IAA5B,EAAkC6B,GAAlC,EAAuClB,KAAvC,EAA8C;AACjD,WAAO;AACHH,cAAM,UADH;AAEHsB,aAAK9B,IAFF;AAGH+B,eAAO/B,IAHJ;AAIH6B,aAAKA,GAJF;AAKHlB,eAAOA;AALJ,KAAP;AAOH","file":"sentence-splitter.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nconst assert = require(\"assert\");\nimport StructureSource from \"structured-source\";\nconst defaultOptions = {\n    // charRegExp is deprecated\n    charRegExp: /[\\.。\\?\\!？！]/,\n    // separator char list\n    separatorChars: [\".\", \"。\", \"?\", \"!\", \"？\", \"！\"],\n    newLineCharacters: \"\\n\"\n};\nexport const Syntax = {\n    \"WhiteSpace\": \"WhiteSpace\",\n    \"Sentence\": \"Sentence\"\n};\n/**\n * @param {string} text\n * @param {{\n *      charRegExp: ?Object,\n *      separatorChars: ?string[],\n *      newLineCharacters: ?String\n *  }} options\n * @returns {Array}\n */\nexport function split(text, options = {}) {\n    const charRegExp = options.charRegExp;\n    const separatorChars = options.separatorChars || defaultOptions.separatorChars;\n    assert(!(options.charRegExp && options.separatorChars), \"should use either one `charRegExp` or `separatorChars`.\\n\"\n        + \"`charRegExp` is deprecated.\");\n    /**\n     * Is the `char` separator symbol?\n     * @param {string} char\n     * @returns {boolean}\n     */\n    const testCharIsSeparator = (char) => {\n        if (charRegExp) {\n            return charRegExp.test(char);\n        }\n        return separatorChars.indexOf(char) !== -1;\n    };\n    const newLineCharacters = options.newLineCharacters || defaultOptions.newLineCharacters;\n    const src = new StructureSource(text);\n    let createNode = (type, start, end) => {\n        let range = [start, end];\n        let location = src.rangeToLocation(range);\n        let slicedText = text.slice(start, end);\n        let node;\n        if (type === Syntax.WhiteSpace) {\n            node = createWhiteSpaceNode(slicedText, location, range);\n        } else if (type === Syntax.Sentence) {\n            node = createSentenceNode(slicedText, location, range);\n        }\n        return node;\n    };\n    let results = [];\n    let startPoint = 0;\n    let currentIndex = 0;\n    let isSplitPoint = false;\n    const newLineCharactersLength = newLineCharacters.length;\n    for (; currentIndex < text.length; currentIndex++) {\n        let char = text[currentIndex];\n        let whiteTarget = text.slice(currentIndex, currentIndex + newLineCharactersLength);\n        if (whiteTarget === newLineCharacters) {\n            // (string)\\n\n            if (startPoint !== currentIndex) {\n                results.push(createNode(Syntax.Sentence, startPoint, currentIndex));\n            }\n            for (let i = 0; i < newLineCharactersLength; i++) {\n                // string(\\n)\n                let startIndex = currentIndex + i;\n                results.push(createNode(Syntax.WhiteSpace, startIndex, startIndex + 1));\n            }\n            // string\\n|\n            startPoint = currentIndex + newLineCharactersLength;\n            isSplitPoint = false;\n        } else if (testCharIsSeparator(char)) {\n            isSplitPoint = true;\n        } else {\n            // why `else`\n            // it for support 。。。 pattern\n            if (isSplitPoint) {\n                results.push(createNode(Syntax.Sentence, startPoint, currentIndex));\n                // reset stat\n                startPoint = currentIndex;\n                isSplitPoint = false;\n            }\n        }\n    }\n\n    if (startPoint !== currentIndex) {\n        results.push(createNode(Syntax.Sentence, startPoint, currentIndex));\n    }\n    return results;\n}\n/**\n * @param {string} text\n * @param {Object} loc\n * @param {number[]} range\n * @returns {{type: string, raw: string, value: string, loc: Object, range: number[]}}\n */\nexport function createWhiteSpaceNode(text, loc, range) {\n    return {\n        type: \"WhiteSpace\",\n        raw: text,\n        value: text,\n        loc: loc,\n        range: range\n    }\n}\n/**\n * @param {string} text\n * @param {Object} loc\n * @param {number[]} range\n * @returns {{type: string, raw: string, value: string, loc: Object, range: number[]}}\n */\nexport function createSentenceNode(text, loc, range) {\n    return {\n        type: \"Sentence\",\n        raw: text,\n        value: text,\n        loc: loc,\n        range: range\n    }\n}"]}